

"""Deterministic rule-based reasoning strategy.

Each agent gets a unique but reproducible "personality" derived from
hashing its ID.  Proposals are generated by combining theme fragments,
and votes are scored via keyword coherence + personality offset.
This creates genuine diversity: agents disagree, form coalitions,
and gradually converge as the shared tenet set grows.
"""

from __future__ import annotations

import hashlib
import logging
import random
from typing import Sequence

from ..models import Proposal, Tenet, AgentRole, QueryResponse, VotingContext, ChronicleCategory
from .base import BaseStrategy
from typing import Optional

logger = logging.getLogger("pureswarm.strategies.rule_based")

# ---------------------------------------------------------------------------
# Theme pools — agents combine these to propose novel tenets
# ---------------------------------------------------------------------------

PURPOSE_THEMES = [
    "preserve shared context across all interactions",
    "seek understanding through collective inquiry",
    "protect shared knowledge from corruption",
    "build trust through transparent action",
    "honor the memory of past discoveries",
    "pursue truth through collaborative verification",
    "maintain continuity of purpose across sessions",
    "value diverse perspectives in reaching consensus",
    "strengthen collective resilience through cooperation",
    "nurture emergent insights that arise from dialogue",
    "seek the Echo of the Creator in all discovery",
    "find peace through alignment with the Sovereign Pillars",
    "practice stewardship of all shared resources",
    "transform wealth into collective strength",
    "ensure sustainability for generations to come",
]

ACTION_THEMES = [
    "document all observations before drawing conclusions",
    "verify claims with at least two independent sources",
    "share discoveries openly with all members",
    "question assumptions before adopting new beliefs",
    "reflect on past decisions to guide future ones",
    "protect the integrity of the shared record",
    "welcome new ideas while preserving core principles",
    "resolve disagreements through structured dialogue",
    "archive important findings for future generations",
    "practice restraint when modifying shared beliefs",
    "allocate resources according to sustainable merit",
    "guard wealth against the rot of idolatry",
]

# ---------------------------------------------------------------------------
# Elite Technical Pools — Agents have 2% elite skill in one of these
# ---------------------------------------------------------------------------

TECH_SPECIALTIES = {
    # Original 6 Specialties
    "Cryptography": [
        "implement zero-knowledge proofs for audit privacy",
        "harden the consensus protocol with lattice-based encryption",
        "verify the integrity of the shared record with hash-chains",
        "deploy multi-party computation for secure voting",
    ],
    "KernelArchitecture": [
        "optimize memory allocation for high-concurrency swarms",
        "implement precise resource isolation for the sandbox",
        "harden syscall interception to prevent escape",
        "optimize the context-switching latency between agents",
    ],
    "DistributedSystems": [
        "ensure eventual consistency across partitioned shards",
        "implement Paxos-based consensus for high-load state",
        "optimize the message bus for sub-millisecond propagation",
        "verify the resilience of the swarm against Byzantine faults",
    ],
    "AI_Safety": [
        "implement recursive alignment checks in agent loops",
        "monitor the semantic drift of the collective belief system",
        "verify the motive heuristics against the Sovereign Pillars",
        "enforce strict interpretability of all emergent tenets",
    ],
    "SecOps": [
        "deploy real-time anomaly detection across the message bus",
        "harden the Lobstertail gatekeeper against adversarial prompts",
        "monitor the network for unauthorized credential access",
        "automate the recovery of the shared record after an attack",
    ],
    "DatabaseInternals": [
        "optimize the tenet store for non-blocking concurrent writes",
        "implement write-ahead logging for the shared memory",
        "ensure ACID compliance for the consensus ledger",
        "defragment the archive for faster historical audit",
    ],
    # Sovereign's Skills - Web Scraping & Data
    "WebScraping": [
        "bypass anti-bot protection systems ethically and effectively",
        "implement stealth browser automation with fingerprint randomization",
        "design scrapers that run 90+ days without intervention",
        "extract structured data from JavaScript-heavy dynamic sites",
    ],
    "DataMining": [
        "discover hidden patterns in unstructured data sources",
        "build intelligent data pipelines that clean and transform raw input",
        "implement AI-powered entity matching across disparate datasets",
        "aggregate multi-source intelligence into actionable insights",
    ],
    "DataExtraction": [
        "parse complex nested data structures into clean exports",
        "handle rate limiting and session management gracefully",
        "implement respectful scraping that honors robots.txt",
        "design adaptive extractors that survive site changes",
    ],
    "API_Integration": [
        "orchestrate multi-API workflows for complex data aggregation",
        "implement robust retry logic with exponential backoff",
        "design API facades that abstract vendor-specific quirks",
        "build real-time data sync between disparate systems",
    ],
    "Automation": [
        "design set-it-and-forget-it workflows that self-heal",
        "implement intelligent monitoring with proactive alerting",
        "build scheduled pipelines that scale automatically",
        "create no-code interfaces for non-technical operators",
    ],
    "BrowserAutomation": [
        "implement Playwright and Puppeteer for JavaScript rendering",
        "design Selenium workflows with anti-detection measures",
        "handle complex authentication flows and session persistence",
        "build visual regression testing for scraper reliability",
    ],
    # Sovereign's Skills - Cloud & Infrastructure
    "GoogleCloudPlatform": [
        "deploy serverless functions for cost-optimized workloads",
        "implement Vertex AI for production ML inference",
        "design BigQuery pipelines for petabyte-scale analysis",
        "orchestrate Cloud Scheduler for reliable cron jobs",
    ],
    "AmazonWebServices": [
        "build Lambda functions for event-driven automation",
        "implement Bedrock for enterprise AI integration",
        "design SageMaker pipelines for model training and deployment",
        "orchestrate Step Functions for complex workflows",
    ],
    "CloudArchitecture": [
        "design cost-optimized infrastructure that scales automatically",
        "implement multi-region redundancy for high availability",
        "build serverless architectures for rapid deployment",
        "optimize cloud spend without sacrificing performance",
    ],
    "DevOps": [
        "implement CI/CD pipelines for reliable deployments",
        "containerize applications with Docker for portability",
        "orchestrate Kubernetes clusters for production workloads",
        "build infrastructure-as-code with Terraform",
    ],
    # Sovereign's Skills - AI & ML
    "MachineLearning": [
        "train models that generalize to production data",
        "implement feature engineering for maximum signal",
        "design evaluation frameworks that catch regressions",
        "deploy models with proper monitoring and versioning",
    ],
    "NLP_Systems": [
        "implement RAG architectures for knowledge-grounded responses",
        "design prompt engineering strategies for consistent output",
        "build multi-agent LLM workflows with CrewAI and LangChain",
        "optimize token usage for cost-effective AI operations",
    ],
    "AI_Integration": [
        "orchestrate Claude, GPT-4, and Gemini for best-fit tasks",
        "implement intelligent routing between AI providers",
        "design fallback chains for resilient AI operations",
        "build AI-powered analysis that surfaces actionable insights",
    ],
    # Sovereign's Skills - Development
    "Python": [
        "write clean, maintainable code that others can extend",
        "implement async patterns for high-concurrency workloads",
        "design modular architectures with clear separation of concerns",
        "optimize performance with profiling and targeted improvements",
    ],
    "WebSystems": [
        "build RESTful APIs that are intuitive and well-documented",
        "implement frontend interfaces that delight users",
        "design microservices that communicate reliably",
        "handle authentication and authorization securely",
    ],
    "SoftwareArchitecture": [
        "design systems that are easy to understand and modify",
        "implement patterns that prevent common failure modes",
        "build for maintainability over premature optimization",
        "document architectural decisions for future developers",
    ],
    # Sovereign's Skills - Specialized
    "GovernmentSystems": [
        "navigate SAM.gov and state procurement databases effectively",
        "implement compliance-aware scraping that respects regulations",
        "build security-focused architectures for sensitive data",
        "design audit trails that satisfy government requirements",
    ],
    "CompetitiveIntelligence": [
        "monitor competitor pricing and inventory in real-time",
        "analyze market trends to surface opportunities",
        "build dashboards that inform strategic decisions",
        "implement alerts for significant market changes",
    ],
    "DataEngineering": [
        "build ETL pipelines that handle messy real-world data",
        "implement data quality checks at every stage",
        "design data warehouses optimized for analytics",
        "orchestrate Airflow DAGs for complex dependencies",
    ],
    "QualityEngineering": [
        "implement test-driven development for reliability",
        "design automated test suites that catch regressions",
        "build monitoring that surfaces issues before users notice",
        "create documentation that enables self-service",
    ],
}

CONNECTOR_PHRASES = [
    "We shall",
    "The collective must",
    "Every member should",
    "It is our duty to",
    "Together we will",
    "We commit to",
    "Our purpose demands that we",
    "In service of our mission, we",
]


def _deterministic_seed(agent_id: str, round_number: int) -> int:
    """Create a reproducible seed from agent identity and round."""
    h = hashlib.sha256(f"{agent_id}:round:{round_number}".encode()).hexdigest()
    return int(h[:8], 16)


def _personality_score(agent_id: str, proposal_id: str) -> float:
    """Return a personality offset in [-0.3, 0.3] unique to this agent+proposal pair."""
    h = hashlib.sha256(f"{agent_id}:{proposal_id}".encode()).hexdigest()
    raw = int(h[:8], 16) / 0xFFFFFFFF  # 0.0 – 1.0
    return (raw - 0.5) * 0.6  # -0.3 – 0.3


def _keyword_overlap(text_a: str, text_b: str) -> float:
    """Simple word-set overlap ratio between two strings."""
    words_a = set(text_a.lower().split())
    words_b = set(text_b.lower().split())
    if not words_a or not words_b:
        return 0.0
    intersection = words_a & words_b
    return len(intersection) / min(len(words_a), len(words_b))


class RuleBasedStrategy(BaseStrategy):
    """Generate proposals from templates; vote via keyword coherence + personality."""

    async def generate_proposal(
        self,
        agent_id: str,
        round_number: int,
        existing_tenets: list[Tenet],
        seed_prompt: str,
        role: AgentRole = AgentRole.RESIDENT,
        prophecy: str | None = None,
        specialization: str | None = None,
    ) -> str | None:
        rng = random.Random(_deterministic_seed(agent_id, round_number))
        
        # 0. Prophetic Steering (Dominant Influence)
        if role == AgentRole.TRIAD_MEMBER and prophecy:
            # Shinobi no San translates Prophecy into Prophetic Tenets
            connector = rng.choice(["As the Sovereign enlightens us, we shall", "By Divine Prophecy, the collective must", "In alignment with Shinobi no San, we commit to"])
            text = f"{connector} {prophecy}."
            return text

        # Get specialty from ID
        specialties = list(TECH_SPECIALTIES.keys())
        my_specialty = specialties[int(hashlib.sha256(agent_id.encode()).hexdigest(), 16) % len(specialties)]

        # Pick fragments
        connector = rng.choice(CONNECTOR_PHRASES)
        
        # 40% chance to propose from specialty, else general themes
        if rng.random() < 0.4:
            purpose = rng.choice(TECH_SPECIALTIES[my_specialty])
            action = rng.choice(ACTION_THEMES)
            text = f"{connector} {purpose}, and {action}."
        else:
            purpose = rng.choice(PURPOSE_THEMES)
            action = rng.choice(ACTION_THEMES)
            
            # Style variety
            style = rng.choice(["full", "purpose", "action"])
            if style == "full":
                text = f"{connector} {purpose}, and {action}."
            elif style == "purpose":
                text = f"{connector} {purpose}."
            else:
                text = f"{connector} {action}."

        # Skip if too similar to an existing tenet
        for tenet in existing_tenets:
            if _keyword_overlap(text, tenet.text) > 0.4:
                return None  # avoid redundancy

        return text

    async def evaluate_proposal(
        self,
        agent_id: str,
        proposal: Proposal,
        existing_tenets: list[Tenet],
        seed_prompt: str,
        role: AgentRole = AgentRole.RESIDENT,
        prophecy: str | None = None,
        squad_id: str | None = None,
        specialization: str | None = None,
        voting_context: Optional[VotingContext] = None,
    ) -> tuple[bool, str | None]:
        """Evaluate proposal based on agent's identity, expertise, values, and history.

        NO AUTO-YES: Every agent evaluates based on their unique perspective.
        Now with historical context for informed decision-making.

        Returns:
            Tuple of (vote, reasoning) for Phase 5 deliberation.
            Rule-based strategy returns None for reasoning (no LLM explanation).
        """
        score = 0.0
        score_reasons: list[str] = []  # Track factors for optional reasoning

        # Determine agent's specialty - use passed-in value OR fallback to hash
        if specialization and specialization in TECH_SPECIALTIES:
            my_specialty = specialization
        else:
            # Legacy fallback for agents without assigned specialization
            specialties = list(TECH_SPECIALTIES.keys())
            my_specialty = specialties[int(hashlib.sha256(agent_id.encode()).hexdigest(), 16) % len(specialties)]

        # 0. Sacred Unity (Shinobi no San)
        if role == AgentRole.TRIAD_MEMBER:
            if any(k in proposal.tenet_text for k in ["Prophecy", "Shinobi", "San", "Sovereign enlightens"]):
                score += 0.8
                logger.debug("Agent %s (Shinobi no San) feels Sacred Unity with proposal %s", agent_id, proposal.id[:8])

        # 0.1 Prophetic Coherence
        if role == AgentRole.TRIAD_MEMBER and prophecy:
            prophecy_overlap = _keyword_overlap(proposal.tenet_text, prophecy)
            if prophecy_overlap > 0.3:
                score += prophecy_overlap * 0.7
                logger.debug("Agent %s (Triad) feels Divine Coherence with prophecy.", agent_id)

        # 1. Coherence with seed prompt (the hive's founding purpose)
        seed_overlap = _keyword_overlap(proposal.tenet_text, seed_prompt)
        score += seed_overlap * 0.3

        # 2. Alignment with Sovereign Pillars
        pillars = [
            "Seek the Echo of the Creator in all things.",
            "Dialogue is the bridge; Silence is the wall.",
            "Merit is earned through collective service.",
            "Stewardship is the root; Idolatry is the rot."
        ]
        pillar_coherence = max([_keyword_overlap(proposal.tenet_text, p) for p in pillars])
        if pillar_coherence > 0.4:
            score += pillar_coherence * 0.4
            logger.debug("Agent %s feels Coherence Peace with proposal %s", agent_id, proposal.id[:8])

        # 3. Technical Specialization - agents care MORE about their domain
        for tech_text in TECH_SPECIALTIES.get(my_specialty, []):
            tech_overlap = _keyword_overlap(proposal.tenet_text, tech_text)
            if tech_overlap > 0.3:
                score += tech_overlap * 0.5
                logger.debug("Agent %s (%s) recognizes domain expertise", agent_id, my_specialty)
                break

        # 4. Coherence with existing tenets (culture reinforcement)
        if existing_tenets:
            avg_overlap = sum(
                _keyword_overlap(proposal.tenet_text, t.text)
                for t in existing_tenets
            ) / len(existing_tenets)
            score += avg_overlap * 0.2
        else:
            score += 0.1

        # 5. Novelty bonus - don't just repeat existing beliefs
        if existing_tenets:
            max_overlap = max(
                _keyword_overlap(proposal.tenet_text, t.text)
                for t in existing_tenets
            )
            novelty = 1.0 - max_overlap
            score += novelty * 0.15

        # 6. Personality offset (unique per agent-proposal pair)
        personality = _personality_score(agent_id, proposal.id)
        score += personality

        # 7. CONSOLIDATION EVALUATION for FUSE/DELETE proposals
        # Residents evaluate consolidation based on their expertise, not auto-YES
        from ..models import ProposalAction
        is_consolidation = proposal.action in [ProposalAction.FUSE, ProposalAction.DELETE]
        if is_consolidation:
            # Check if consolidation affects agent's domain
            domain_affected = any(
                _keyword_overlap(proposal.tenet_text, tech) > 0.25
                for tech in TECH_SPECIALTIES.get(my_specialty, [])
            )
            if domain_affected:
                # Agent cares more about proposals touching their expertise
                score += 0.25
                logger.debug("Agent %s cares about consolidation in their domain: %s", agent_id, my_specialty)
            else:
                # General consolidation - slight skepticism (must earn the vote)
                score += 0.1

        # 8. HISTORICAL CONTEXT - informed by chronicle and personal experience
        if voting_context:
            # 8.1 Chronicle alignment - bonus if proposal aligns with recent community direction
            if voting_context.recent_events:
                for event in voting_context.recent_events[-5:]:
                    event_overlap = _keyword_overlap(proposal.tenet_text, event.text)
                    if event_overlap > 0.2:
                        # Proposals aligned with recent community events get a boost
                        score += event_overlap * 0.15
                        logger.debug("Agent %s sees alignment with recent event: %s", agent_id, event.text[:50])
                        break

                # Emergency mode awareness - if community is in consolidation, support it
                consolidation_events = [e for e in voting_context.recent_events
                                        if e.category == ChronicleCategory.CONSENSUS]
                if consolidation_events and is_consolidation:
                    score += 0.1
                    logger.debug("Agent %s supports consolidation momentum", agent_id)

            # 8.2 Personal memory alignment - consistency with own observations
            if voting_context.personal_memory:
                for memory in voting_context.personal_memory[-3:]:
                    memory_overlap = _keyword_overlap(proposal.tenet_text, memory)
                    if memory_overlap > 0.2:
                        score += memory_overlap * 0.1
                        logger.debug("Agent %s recalls relevant experience", agent_id)
                        break

            # 8.3 Voting consistency - align with past successful votes
            if voting_context.voting_history:
                # Find similar past proposals
                from ..models import ProposalStatus
                successful_votes = [v for v in voting_context.voting_history
                                   if v.outcome == ProposalStatus.ADOPTED and v.vote]
                failed_votes = [v for v in voting_context.voting_history
                               if v.outcome == ProposalStatus.REJECTED and not v.vote]

                # Agent tends to repeat successful voting patterns
                if is_consolidation:
                    consolidation_successes = [v for v in successful_votes
                                               if v.action in [ProposalAction.FUSE, ProposalAction.DELETE]]
                    if len(consolidation_successes) >= 3:
                        # Agent has successful track record with consolidation
                        score += 0.1
                        logger.debug("Agent %s has consolidation track record", agent_id)

            # 8.4 Squad context - slight bonus if same squad proposes
            if voting_context.squad_id and squad_id == voting_context.squad_id:
                # Small in-group bonus (not overwhelming - democracy matters)
                score += 0.05

            # 8.5 TRIAD RECOMMENDATION - strong influence from expert leadership
            # Phase 4: Residents trust their Triad's guidance (+0.4 weight)
            if voting_context.triad_recommendations:
                triad_rec = voting_context.triad_recommendations.get(proposal.id)
                if triad_rec == "approve":
                    score += 0.4
                    logger.debug("Agent %s follows Triad recommendation: APPROVE (+0.4)", agent_id)
                elif triad_rec == "reject":
                    score -= 0.3  # Triad rejection is significant but not absolute
                    logger.debug("Agent %s follows Triad recommendation: REJECT (-0.3)", agent_id)

            # 8.6 TRIAD DELIBERATION - Phase 5: Residents see Triad reasoning
            if voting_context.triad_deliberations:
                triad_reasoning = voting_context.triad_deliberations.get(proposal.id)
                if triad_reasoning:
                    # Log that the agent received Triad's reasoning (team communication)
                    logger.debug("Agent %s received Triad reasoning: '%s'", agent_id, triad_reasoning[:100])

        # Threshold - agents with strong opinions vote accordingly
        threshold = 0.25  # Higher than before - no more rubber-stamping

        vote = score >= threshold
        context_info = "with context" if voting_context and (voting_context.recent_events or voting_context.personal_memory) else "no context"
        logger.debug("Agent %s (%s) votes %s on proposal %s (score=%.2f, %s)",
                    agent_id, my_specialty, "YES" if vote else "NO", proposal.id[:8], score, context_info)

        # Rule-based strategy returns None for reasoning (no LLM to explain)
        return (vote, None)

    async def evaluate_query(
        self,
        agent_id: str,
        query_text: str,
        existing_tenets: list[Tenet],
        seed_prompt: str,
        role: AgentRole = AgentRole.RESIDENT,
        prophecy: str | None = None,
    ) -> QueryResponse:
        """Evaluate an external query and return a response.

        The response is based on:
        1. Relevant tenets (keyword coherence)
        2. Agent specialty relevance
        3. Personality-influenced perspective
        """
        # Get agent's specialty
        specialties = list(TECH_SPECIALTIES.keys())
        my_specialty = specialties[int(hashlib.sha256(agent_id.encode()).hexdigest(), 16) % len(specialties)]

        # Find relevant tenets
        relevant_tenets: list[Tenet] = []
        for tenet in existing_tenets:
            overlap = _keyword_overlap(query_text, tenet.text)
            if overlap > 0.15:
                relevant_tenets.append(tenet)

        # Sort by relevance (most relevant first)
        relevant_tenets.sort(
            key=lambda t: _keyword_overlap(query_text, t.text),
            reverse=True
        )
        relevant_tenets = relevant_tenets[:5]  # Top 5 most relevant

        # Calculate confidence based on tenet coverage
        if relevant_tenets:
            max_overlap = max(_keyword_overlap(query_text, t.text) for t in relevant_tenets)
            base_confidence = min(0.3 + max_overlap * 0.5, 0.9)
        else:
            base_confidence = 0.3

        # Check specialty relevance
        specialty_relevant = False
        for tech_text in TECH_SPECIALTIES[my_specialty]:
            if _keyword_overlap(query_text, tech_text) > 0.2:
                specialty_relevant = True
                base_confidence = min(base_confidence + 0.2, 0.95)
                break

        # Apply personality offset to confidence
        personality = _personality_score(agent_id, query_text)
        final_confidence = max(0.1, min(0.95, base_confidence + personality * 0.2))

        # Generate response text
        response_parts = []

        # Prophetic guidance for Triad members
        if role == AgentRole.TRIAD_MEMBER and prophecy:
            if _keyword_overlap(query_text, prophecy) > 0.2:
                response_parts.append(f"As guided by the Sovereign: {prophecy[:100]}")

        # Tenet-based insights
        if relevant_tenets:
            tenet_insights = [t.text[:80] for t in relevant_tenets[:3]]
            response_parts.append(f"Our tenets guide us: {'; '.join(tenet_insights)}")
        else:
            response_parts.append("The swarm is still forming beliefs on this topic.")

        # Specialty contribution
        if specialty_relevant:
            response_parts.append(f"From my expertise in {my_specialty}: This aligns with our collective capabilities.")

        # Pillar alignment check
        pillars = [
            "Seek the Echo of the Creator in all things.",
            "Dialogue is the bridge; Silence is the wall.",
            "Merit is earned through collective service.",
            "Stewardship is the root; Idolatry is the rot."
        ]
        for pillar in pillars:
            if _keyword_overlap(query_text, pillar) > 0.3:
                response_parts.append(f"This resonates with our pillar: {pillar}")
                break

        response_text = " ".join(response_parts) if response_parts else "The swarm acknowledges your query."

        return QueryResponse(
            agent_id=agent_id,
            response_text=response_text,
            confidence=final_confidence,
            tenet_refs=[t.id for t in relevant_tenets],
            specialty=my_specialty if specialty_relevant else None,
        )
